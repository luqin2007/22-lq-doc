将 AST 转换为二进制 Chunk 分为两个阶段
1. 处理 AST，生成自定义内部结构
2. 将内部结构转换为函数原型
# funcInfo

`funcInfo` 结构体用于存储函数内部结构
## 常量表

常量表主要维护一个常量 - 索引的表

```go title:compiler/codegen/func_info.go
type funcInfo struct {
    // 常量表: map[常量]索引
	constants map[interface{}]int
}

// indexOfConstant 在常量表中查找索引，若不存在则存入常量表
func (self *funcInfo) indexOfConstant(constVal interface{}) int {
	if index, ok := self.constants[constVal]; ok {
		return index
	}

	index := len(self.constants)
	self.constants[constVal] = index
	return index
}
```
## 寄存器

寄存器主要维护申请寄存器（索引从 0 开始）、回收寄存器，并计算使用的寄存器最大数量

> [!failure] 注意 Lua 最大支持 255 个寄存器

```go title:compiler/codegen/func_info.go
type funcInfo struct {
    // 寄存器
	usedRegs  int
	maxRegs   int
}

// allocReg 分配一个寄存器，返回寄存器索引
func (self *funcInfo) allocReg() int {
	return self.allocRegs(1)
}

// allocReg 分配多个寄存器，返回第一个寄存器的索引
func (self *funcInfo) allocRegs(n int) int {
	self.usedRegs += n
	if self.usedRegs >= 255 {
		panic("function or expression needs too many registers")
	}
	if self.usedRegs > self.maxRegs {
		self.maxRegs = self.usedRegs
	}
	return self.usedRegs - n
}

// freeReg 回收上一个分配的寄存器
func (self *funcInfo) freeReg() {
	self.usedRegs--
}

// freeReg 回收最近分配的多个寄存器
func (self *funcInfo) freeRegs(n int) {
	self.usedRegs -= n
}
```
## 局部变量表

局部变量表在记录局部变量本身信息的同时，还需要记录其他信息：
- 所在作用域层次：便于离开作用域时清理变量
- 是否被闭包捕获，决定是否为 upvalue

```go title:compiler/codegen/func_info.go
type funcInfo struct {
	// 局部变量表
	scopeLv  int
	locVars  []*locVarInfo
	locNames map[string]*locVarInfo
}

type locVarInfo struct {
	prev     *locVarInfo // 所有同名变量在一个链表上
	name     string
	scopeLv  int
	slot     int
	captured bool
}

// enterScope 进入一个作用域 scope
func (self *funcInfo) enterScope() {
	self.scopeLv++
}

// addLocVar 向该作用域添加一个局部变量，返回分配的寄存器索引
func (self *funcInfo) addLocVar(name string) int {
	newVar := &locVarInfo{
		name:    name,
		prev:    self.locNames[name],
		scopeLv: self.scopeLv,
		slot:    self.allocReg(),
	}
	self.locVars = append(self.locVars, newVar)
	self.locNames[name] = newVar
	return newVar.slot
}

// slotOfLocVar 获取局部变量绑定的寄存器，未绑定返回 -1
func (self *funcInfo) slotOfLocVar(name string) int {
	if locVar, ok := self.locNames[name]; ok {
		return locVar.slot
	}
	return -1
}

// exitScope 离开作用域
func (self *funcInfo) exitScope() {
	self.scopeLv--
	for _, locVar := range self.locNames {
		if locVar.scopeLv > self.scopeLv {
			self.removeLocVar(locVar)
		}
	}
}

// 移除作用域变量
func (self *funcInfo) removeLocVar(locVar *locVarInfo) {
    self.freeReg()
    if locVar.prev == nil {
        // 没有变量覆盖 - 直接删除
        delete(self.locNames, locVar.name)
    } else if locVar.prev.scopeLv == locVar.scopeLv {
        // 覆盖的变量与当前变量作用域相同 - 删除覆盖的变量
        self.removeLocVar(locVar.prev)
    } else {
        // 使用被覆盖的变量
        self.locNames[locVar.name] = locVar.prev
    }
}
```
## break 表

`break` 处理有两个问题：
- 可能需要穿透块找到最近的 `for`，`while` 或 `repeat`
- 处理 `break` 时循环未结束，目标地址不确定

将 `break` 用到的跳转指令写入循环块中，等块结束时修复