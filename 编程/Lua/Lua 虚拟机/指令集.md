Lua 在 5.0 前是基于栈的虚拟机，5.0 之后更改为基于寄存器的虚拟机（因此寄存器数量字段还是 `MaxStackSize` 😂）

Lua 指令集为定长指令集，每条指令 4 字节（32bit），其中 6bit 用于操作码，26bit 用于操作数，共 47 条指令
# 指令编码

Lua 编码模式有三种：`iABC`，`iABx`，`iAsBx`，`iAx`

`````col
````col-md
flexGrow=1
===
- `iABC`：携带 ABC 三个操作数，分别占用 8+9+9 bit，共 39 条
- `iABx`：携带 A、Bx 两个操作数，分别占用 8+18 bit，共 3 条
- `iAsBx`：携带 A、sBx 两个操作数，分别占用 8+18 bit，共 4 条
- `iAx`：只携带 1 个操作数，占用 26bit，有 1 条
````
````col-md
flexGrow=1
===
![[../../../_resources/images/指令集 2024-11-20 01.07.39.excalidraw]]
````
`````
## 操作码

从 0 到 46 共 47 条指令，声明一下即可，详见 [Lua 5.3 Bytecode Reference](https://the-ravi-programming-language.readthedocs.io/en/latest/lua_bytecode_reference.html#instruction-summary)
## 操作数

操作数大致可以分为 `A`，`OpArgN`，`OpArgU`，`OpArgR`，`OpArgK` 几种
- `A`：目标寄存器索引
- `OpArgN`：不使用，如 `MOVE` 的 C 操作数
- `OpArgR`：`iABC` 下表示寄存器索引，`iAsBx` 下表示跳转偏移
- `OpArgK`：`LOADK` 表示常量索引，`iABC` 模式表示常量索引或寄存器索引，最高位 1 表示常量索引
- `OpArgU`：布尔、整数、Upvalue 索引、子函数索引等
## 指令表

指令表结构体：

```reference
file: "@/_resources/codes/go-luacompiler/vm/opcodes.go"
lang: "go"
start: 69
end: 77
```

为所有指令创建对应值即可

```reference fold
file: "@/_resources/codes/go-luacompiler/vm/opcodes.go"
lang: "go"
start: 76
end: 123
```

# 指令解码

创建 `uint32` 别名 `Instruction`，并为其创建参数提取方法

```reference fold
file: "@/_resources/codes/go-luacompiler/vm/instruction.go"
lang: "go"
start: 3
end: 37
```

>[!note] AsBx 方法：偏移二进制码编码模式
> Offset Binary，又称 Excess-K。当 `sBx` 解释成无符号整型时为 `x`，则解释成有符号整型时为 `x-K`，`K` 为 `sBx` 类型可取最大值的一半，即 `MAXARG_sBx `
