Lua 内置的复杂数据类型只有表 Table 一种。表在 Lua 中可以直接作为数组、列表使用，也被用来实现全局变量、元编程、包和模块等。

Lua 表的本质是关联数组，在其他语言中称为 `map` 或 `dict` 等。

Lua 表的键可以是除了 `nil` 和 `NaN` 外的所有数据，值则可以是任意数据。
- 键全部是字符串的表称为**记录** Record
- 键全部是正整数的表称为**列表**（**数组**）List，建表时忽略键即可创建数组：`{ "A", "B", "C" }`
- 数组中包含的 `nil` 值称为**洞**，没有**洞**的数组称为**序列**
- 当作为键时，实际表示整数的浮点数会被转换为整数

# 表实现

表结构包含 `arr` 和 `_map` 两部分，`arr` 存储表的数组部分，`_map` 存储表的其他数据。

```reference
file: "@/_resources/codes/go-luacompiler/state/lua_table.go"
lang: "go"
start: 8
end: 26
```

实现 `get` 和 `put` 方法时需要对 `key` 进行预处理，若类型为 `float64` 则尝试转换为 `int64`

```reference
file: "@/_resources/codes/go-luacompiler/state/lua_table.go"
lang: "go"
start: 86
end: 94
```

> [!attention] 注意处理 `arr` 和 `_map` 可能为 `nil`

`get` 流程：
1. 预处理 `key`，尝试转换为 `int64`
2. 若键为正整数，且在数组长度范围内，直接返回 `table.arr[key]`
3. 根据 `key` 返回 `table._map` 中的值，若不存在则返回 `nil`

`set` 流程：
1. 预处理 `key`，尝试转换为 `int64`
2. 若值为 `nil`，则删除值；否则，插入值
3. 删除值：
	1. 若 `key` 为整型且在列表中，置为 `nil` 并压缩数组
	2. 从 `_map` 中移除键
4. 插入值：
	1. 若 `key` 为正整数，扩充 `arr` 并设置值
	2. 否则，存入 `_map` 中

扩充和缩减数组：

```reference
file: "@/_resources/codes/go-luacompiler/state/lua_table.go"
lang: "go"
start: 96
end: 121
```

# 相关指令

| 指令         | 类型     | 说明                                         |
| ---------- | ------ | ------------------------------------------ |
| `NEWTABLE` | `iABC` | 创建空表，并将其放入寄存器 A。表的数组容量为 B，哈希表容量为 C         |
| `GETTABLE` | `iABC` | 表位于寄存器 B 中，键位于寄存器或常量 C 中，从表中取值并放入寄存器 A 中   |
| `SETTABLE` | `iABC` | 表位于寄存器 A 中，键和值位于寄存器或常量 B、C 中，将键值对存入表中      |
| `SETLIST`  | `iABC` | 表位于寄存器 A 中，写入值的数量为 B，数组索引起点为 C，向表数组部分连续写入值 |
-  `NEWTABLE` 中 B、C 容量使用浮点字节编码模式（FPB）以表示更大的范围
-  `SETLIST` 指令索引 C 配合 `EXTRAARG` 指令实现最大 `50*512` 的下标

