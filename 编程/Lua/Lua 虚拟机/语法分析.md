> [!note] 歧义：设 L 为上下文无关语言，则可以将其转换为解析树 CST。对于任意 L 源代码，若仅能被转换为唯一 CST，称 L 语言**无歧义**Unambiguous，否则称 L 语言**有歧义** Ambiguous

常见歧义如 C 语言悬挂 `else` 问题，通过额外的规则解决。

Lua 没有 `else` 歧义，但也存在运算符表达式的歧义，通过运算符优先级和结合律解决。
# 前瞻与回溯

> [!note] 前瞻：Lookahead，预先读取后面几个 Token 以决定下一步解析策略的做法

前瞻解决的是仅通过当前 Token 和下一个 Token，无法确定实际的解析方式的情况，如赋值和函数调用都可以以 `prefixexp` 开头，而 `prefixexp` 可以有多个 Token 组成

```ebnf
stat ::= varlist '=' explist
varlist ::= var {',' var}
var ::= Name | prefixexp '[' exp ']' | prefixexp '.' Name

functioncall ::= prefixexp [':' Name] args

prefixexp ::= var | functioncall | '(' exp ')'
```

此时，只能记录当前状态，挑选一个尝试解析；如果解析失败，则**回溯**后选择其他路径继续尝试

> [!note] 回溯：Backtracking，前瞻失败后记录状态进行尝试并可能回退的做法

回溯会导致解析器无法在线型时间内完成工作，应尽量避免
# 解析方式

生成解析树的方式有两种：
- 自顶向下：先构造树根，如 LL 解析器、递归下降解析器
- 自底向上：先构造树叶，如 LR 解析器和 CYK 解析器
本实例创建的是 Lua 的递归下降解析器
# 解析器
## 解析语句

根据各语句特征，大部分语句都可以通过**前瞻**一次确定，而 `prefixexp` 由于可以无限次嵌套无法一次前瞻完成

```go fold title:compiler/parser/parse_stat.go
func parseStat(lexer *Lexer) ast.Stat {
	switch lexer.LookAhead() {
	case TOKEN_SEP_SEMI: // ;
		return parseEmptyStat(lexer)
	case TOKEN_KW_BREAK: // break
		return parseBreakStat(lexer)
	case TOKEN_SEP_LABEL: // :: ...
		return parseLabelStat(lexer)
	case TOKEN_KW_GOTO: // goto ...
		return parseGotoStat(lexer)
	case TOKEN_KW_DO: // do ...
		return parseDoStat(lexer)
	case TOKEN_KW_WHILE: // while ...
		return parseWhileStat(lexer)
	case TOKEN_KW_REPEAT: // repeat ...
		return parseRepeatStat(lexer)
	case TOKEN_KW_IF: // if ...
		return parseIfStat(lexer)
	case TOKEN_KW_FOR: // for ...
		return parseForStat(lexer)
	case TOKEN_KW_FUNCTION: // function ...
		return parseFuncDefStat(lexer)
	case TOKEN_KW_LOCAL: // local ...
		return parseLocalAssignOrFuncDefStat(lexer)
	default: // 无法通过前瞻一次获取
		return parseAssignOrFuncCallStat(lexer)
	}
}
```

`prefixexp` 相关的两组语句为函数调用和赋值语句，二者理论上可以有无限次嵌套

```ebnf
stat ::= functioncall
stat ::= varlist '=' explist

prefixexp ::= var
    | functioncall
    | '(' exp ')'

functioncall ::= prefixexp args
    | prefixexp ':' Name args

args ::= '(' [explist] ')' | tableconstructor | LiteralString

varlist ::= var {',' var}

var ::= Name
    | prefixexp '[' exp ']'
    | prefixexp '.' Name
```

观察其特征，

根据语法，将 Token 组成树即可，构建时需要补充省略写法和解语法糖
