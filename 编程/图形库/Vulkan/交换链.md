> [!note] 交换链：将图像用于渲染或其他类型的写入时，已渲染好的图像可以被呈现引擎读取，如此交替呈现在窗口中的数张图像的集合即为交换链。
> 一个交换链类似于 OpenGL 的一个帧缓冲区
# 创建交换链

交换链创建信息对象 `VkSwapchainCreateInfoKHR` 如下：

| 成员                      | 类型                              | 说明                                                                                                                                                                                             |
| ----------------------- | ------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `sType`                 |                                 | `VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR`                                                                                                                                                  |
| `surface`               | `VkSurfaceKHR`                  | Window surface                                                                                                                                                                                 |
| `minImageCount`         | `uint32_t`                      | 交换链中图像的最少数量                                                                                                                                                                                    |
| `imageFormat`           | `VkFormat`                      | 交换链中图像的格式<br>- Rn、Gn、Bn、An：各通道位数<br>- U：底层是无符号整型<br>- NORM：自动标准化（转换为 `[0, 1]`）                                                                                                                 |
| `imageColorSpace`       | `VkColorSpaceKHR`               | 交换链中图像的色彩空间                                                                                                                                                                                    |
| `imageExtent`           | `VkExtent2D`                    | 交换链图像的尺寸                                                                                                                                                                                       |
| `imageArrayLayers`      | `uint32_t`                      | 视点数，用于多视点（multiview）或立体显示设备，普通显示器为 1                                                                                                                                                           |
| `imageUsage`            | `VkImageUsageFlags`             | 交换链中图像的用途<br>- `VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT`：颜色附件，必选<br>- `VK_IMAGE_USAGE_TRANSFER_DST_BIT`：数据传输目标，可用于 `vkCmdClearColorImage` 等方法<br>- `VK_IMAGE_USAGE_TRANSFER_SRC_BIT`：数据传输来源，可实现截屏等 |
| `imageSharingMode`      | `VkSharingMode`                 | 交换链中图像的分享模式，单个队列族独占访问 `VK_SHARING_MODE_EXCLUSIVE` 以达到最佳性能                                                                                                                                      |
| `queueFamilyIndexCount` | `uint32_t`                      | 若 `imageSharingMode` 为 `VK_SHARING_MODE_CONCURRENT`，指定将会访问交换链图像的队列族总数                                                                                                                          |
| `pQueueFamilyIndices`   | `const uint32_t*`               | 续上一条，以及具体的队列族索引                                                                                                                                                                                |
| `preTransform`          | `VkSurfaceTransformFlagBitsKHR` | 对交换链图像的变换，比如旋转90°、镜像等                                                                                                                                                                          |
| `compositeAlpha`        | `VkCompositeAlphaFlagBitsKHR`   | 指定如何处理交换链图像的透明度<br>- `VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR`：由其他代码（包括系统窗口）指定                                                                                                                      |
| `presentMode`           | `VkPresentModeKHR`              | 呈现方式                                                                                                                                                                                           |
| `clipped`               | `VkBool32`                      | 是否允许舍弃掉交换链图像应有但窗口中不会显示的像素                                                                                                                                                                      |
| `oldSwapchain`          | `VkSwapchainKHR`                | 旧的交换链，在重建交换链时填入                                                                                                                                                                                |
## 交换链信息

交换链中很多信息都需要从设备 Surface 信息 `VkSurfaceCapabilitiesKHR` 获取

```cpp title:Swapchain::initialize
VkSurfaceCapabilitiesKHR surfaceCapabilities; // 设备信息
auto result = vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, &surfaceCapabilities);
returnVkError("Failed to get physical device surface capabilities!");
```

```cpp title:Swapchain::initialize
swapchainCreateInfo = {
        .sType = VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR,
        .flags = flags,
        .surface = surface,
        // 交换链图像数量
        .minImageCount = minImageCount,
        // 图像大小
        .imageExtent = imageExtent,
        .imageArrayLayers = 1,
        .imageUsage = imageUsage,
        .imageSharingMode = VK_SHARING_MODE_EXCLUSIVE,
        .preTransform = surfaceCapabilities.currentTransform,
        .compositeAlpha = compositeAlpha,
        .presentMode = limitFrameRate,
        .clipped = VK_TRUE,
};
```
### 图像大小 imageExtent

该设备信息从 `surfaceCapabilities` 的 `currentExtent` 属性获取。

长或宽的值可能为 -1，表示当前 Window Surface 大小未指定，此时可以指定一个默认值。

```cpp title:Swapchain::initialize
imageExtent = {
        .width  = glm::clamp(defaultWidth, surfaceCapabilities.minImageExtent.width,
                             surfaceCapabilities.maxImageExtent.width),
        .height = glm::clamp(defaultHeight, surfaceCapabilities.minImageExtent.height,
                             surfaceCapabilities.maxImageExtent.height)
},
```
### 图像队列数量 minImageCount

通常，若容许的最小值与最大值数量不等，取最小值 + 1
- 图像队列不宜过少，否则会产生阻塞，即需要渲染一个新图像时，图像队列满（正在被呈现或被渲染）；
- 图像队列不宜过多，否则产生过多的显存开销

> [!note] 一般 `surfaceCapabilities.minImageCount` 为 2，多一张图可实现三重缓冲

```cpp title:Swapchain::initialize
minImageCount = surfaceCapabilities.minImageCount +
                 (surfaceCapabilities.maxImageCount > surfaceCapabilities.minImageCount),
```
### 透明通道模式 compositeAlpha

该参数指定处理交换链图像透明度通道的方式
- `VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR`：不透明，`alpha` 通道视为 1
- `VK_COMPOSITE_ALPHA_PRE_MULTIPLIED_BIT_KHR`：预乘透明度模式
- `VK_COMPOSITE_ALPHA_POST_MULTIPLIED_BIT_KHR`：后乘透明度模式
- `VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR`：由应用程序其他部分指定

> [!note] 透明度不一定由 Vulkan 决定，还有可能被窗口系统影响。此时应将 `compositeAlpha` 设置为 `VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR`

```cpp title:Swapchain::initialize
VkCompositeAlphaFlagBitsKHR compositeAlpha; // 透明通道模式
if (surfaceCapabilities.supportedCompositeAlpha & VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR) {
    compositeAlpha = VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR;
} else {
    // 这里选取第一个可用的模式
    for (size_t i = 0; i < 4; i++) {
        if (surfaceCapabilities.supportedCompositeAlpha & (1 << i)) {
            compositeAlpha = static_cast<VkCompositeAlphaFlagBitsKHR>(1 << i);
            break;
        }
    }
}
```
### 图像用途 imageUsage

使用 `surfaceCapabilities.supportedUsageFlags` 获取所有可用的用途
- 至少有一个 `VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT` 表示颜色附件
- `VK_IMAGE_USAGE_TRANSFER_DST_BIT`：数据传输目标，可用于 `vkCmdClearColorImage` 或 `vkCmdBlitImage`
- `VK_IMAGE_USAGE_TRANSFER_SRC_BIT`：数据传输来源，可用于窗口截屏

```cpp title:Swapchain::initialize
VkImageUsageFlags imageUsage = VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT; // 图像用途
if (surfaceCapabilities.supportedUsageFlags & VK_IMAGE_USAGE_TRANSFER_DST_BIT) {
    imageUsage |= VK_IMAGE_USAGE_TRANSFER_DST_BIT;
}
if (surfaceCapabilities.supportedUsageFlags & VK_IMAGE_USAGE_TRANSFER_SRC_BIT) {
    imageUsage |= VK_IMAGE_USAGE_TRANSFER_SRC_BIT;
}
```
### 图像格式与色彩空间

图像格式 `VkFormat` ，色彩空间 `VkColorSpaceKHR`
- 图像格式可以不指定（即 `VK_FORMAT_UNDEFINED`）
- 必须指定色彩空间，色彩空间对后续贴图格式、着色器色调映射影响很大
- 可能需要在已经开始的情况下修改色彩空间，需要重建交换链

图像格式具体可见[[图像#图像格式]]

```cpp title:Swapchain::initialize
if (availableSurfaceFormats.empty()) {
    result = getSurfaceFormats();
    returnVkError("Failed to get surface formats!");
}
if (!swapchainCreateInfo.imageFormat) {
    if (setSurfaceFormat({ VK_FORMAT_R8G8B8A8_UNORM, VK_COLOR_SPACE_SRGB_NONLINEAR_KHR }) &&
        setSurfaceFormat({ VK_FORMAT_B8G8R8A8_UNORM, VK_COLOR_SPACE_SRGB_NONLINEAR_KHR })) {
        // 两种情况都不支持，有啥用啥
        swapchainCreateInfo.imageFormat = availableSurfaceFormats[0].format;
        swapchainCreateInfo.imageColorSpace = availableSurfaceFormats[0].colorSpace;
        printVkWarning("Failed to select a four-component UNORM surface format!");
    }
}
```

首先，获取所有可用的图像格式和色彩空间

```cpp
VkResult Swapchain::getSurfaceFormats() {
    auto physicalDevice = vk::Device::base().getPhysicalDevice();
    VkSurfaceKHR surface = vk::VulkanInstance::base().getSurface();

    uint32_t surfaceFormatCount;
    auto result = vkGetPhysicalDeviceSurfaceFormatsKHR(physicalDevice, surface, &surfaceFormatCount, nullptr);
    returnVkError("Failed to get the count of surface formats!");
    if (!surfaceFormatCount) {
        returnVkMessage("Failed to find any supported surface format!");
    }
    availableSurfaceFormats.resize(surfaceFormatCount);
    
    result = vkGetPhysicalDeviceSurfaceFormatsKHR(physicalDevice, surface, &surfaceFormatCount, availableSurfaceFormats.data());
    returnVkError("Failed to get surface formats!");
    return VK_SUCCESS;
}
```

之后，检查并选取可用图像格式和色彩空间。由于可能在已经渲染后使用，所以单独创建一个函数

```cpp
VkResult setSurfaceFormat(VkSurfaceFormatKHR surfaceFormat) {
    // 匹配
    bool available = false;
    if (!surfaceFormat.format) {
        // 只匹配色彩空间
        for (const auto &f: availableSurfaceFormats) {
            if (f.colorSpace == surfaceFormat.colorSpace) {
                swapchainCreateInfo.imageFormat = f.format;
                swapchainCreateInfo.imageColorSpace = f.colorSpace;
                available = true;
                break;
            }
        }
    } else {
        // 只匹配色彩空间
        for (const auto &f: availableSurfaceFormats) {
            if (f.colorSpace == surfaceFormat.colorSpace && f.format == surfaceFormat.format) {
                swapchainCreateInfo.imageFormat = f.format;
                swapchainCreateInfo.imageColorSpace = f.colorSpace;
                available = true;
                break;
            }
        }
    }
    if (!available)
        return VK_ERROR_FORMAT_NOT_SUPPORTED;
    // 重建
    if (handle)
        return recreateSwapchain();
    return VK_SUCCESS;
}
```
### 呈现模式 presentMode

```cpp title:Swapchain::initialize
presentMode = limitFrameRate ? VK_PRESENT_MODE_FIFO_RELAXED_KHR : VK_PRESENT_MODE_MAILBOX_KHR;
```

垂直同步优选选择 `VK_PRESENT_MODE_FIFO_RELAXED_KHR`，不限帧率优先选择 `VK_PRESENT_MODE_MAILBOX_KHR`
- `VK_PRESENT_MODE_IMMEDIATE_KHR`：立即模式，不限制帧率，不等待垂直同步信号，渲染后立即呈现，可能画面撕裂
- `VK_PRESENT_MODE_FIFO_KHR`：先入先出，与屏幕刷新率一致，必定支持。来不及呈现的图片存于队列
- `VK_PRESENT_MODE_FIFO_RELAXED_KHR`：先进先出，但来不及呈现的图片直接丢弃，可能造成画面撕裂
- `VK_PRESENT_MODE_MAILBOX_KHR`：类似于三重缓冲的模式，渲染缓冲只有一个元素，有新渲染的图片时立刻呈现缓存内的图片

![[../../../_resources/images/Pasted image 20250315003029.png|250]]  ![[../../../_resources/images/Pasted image 20250315002949.png|250]]  ![[../../../_resources/images/Pasted image 20250315003141.png|250]]
### 透明窗口背景

一种实现透明背景窗口的方法

- `glfwWindowHint(GLFW_TRANSPARENT_FRAMEBUFFER, GL_TRUE)`，实质是 `DwmEnableBlurBehindWindow`
- `compositeAlpha` 设置为 `VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR`
- 使用 `VkClearColorValue({0f, 0f, 0f, 0f})` 清屏
- `presentMode` 设置为 `VK_PRESENT_MODE_IMMEDIATE_KHR` 或 `VK_PRESENT_MODE_MAILBOX_KHR`（但不限制帧数，浪费性能）
# 交换链对象

## 交换链

```cpp title:Swapchain::createSwapchainInternal
// 创建交换链
auto result = vkCreateSwapchainKHR(device, &swapchainCreateInfo, nullptr, &handle);  
returnVkError("Failed to allocate a swapchain!");
```
## 交换链图像

通过交换链获取交换链图像

```cpp title:Swapchain::createSwapchainInternal
// 获取交换链
uint32_t swapchainImageCount;  
result = vkGetSwapchainImagesKHR(device, handle, &swapchainImageCount, nullptr);  
returnVkError("Failed to get the count of swapchain images!");  
swapchainImages.resize(swapchainImageCount);  

result = vkGetSwapchainImagesKHR(device, handle, &swapchainImageCount, swapchainImages.data());  
returnVkError("Failed to get swapchain images!");
```
## 图像视图

每个交换链图像对应一个图像视图 `ImageView`，

```cpp title:Swapchain::createSwapchainInternal
// 创建 ImageView
swapchainImageViews.resize(swapchainImageCount);
VkImageViewCreateInfo imageViewCreateInfo = {
        .sType = VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO,
        .viewType = VK_IMAGE_VIEW_TYPE_2D,
        .format = swapchainCreateInfo.imageFormat,
        .subresourceRange = {
                .aspectMask = VK_IMAGE_ASPECT_COLOR_BIT,
                .baseMipLevel = 0,
                .levelCount = 1,
                .baseArrayLayer = 0,
                .layerCount = 1
        }
};
for (size_t i = 0; i < swapchainImageCount; i++) {
    imageViewCreateInfo.image = swapchainImages[i];
    result = vkCreateImageView(device, &imageViewCreateInfo, nullptr, &swapchainImageViews[i]);
    returnVkError("Failed to allocate a swapchain image view!");
}
```
# 重建交换链

当调整色彩空间等属性后，需要重建交换链
1. 窗口大小为 0 表示最小化或其他情况没有显示窗口，不需要重建，否则一些显卡驱动会报错
2. 将旧交换链置入创建信息中，以便 Vulkan 重用某些资源
3. 销毁 ImageView，不需要销毁 Swapchain Image，会在 Swapchain 销毁时自动销毁

```cpp
VkResult Swapchain::recreateSwapchain() {
    VkSurfaceCapabilitiesKHR surfaceCapabilities;
    auto result = vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, &surfaceCapabilities);
    returnVkError("Failed to get physical surface capabilities!");
    // 处理窗口大小
    if (surfaceCapabilities.currentExtent.width == 0 || surfaceCapabilities.currentExtent.height == 0) {
        return VK_SUBOPTIMAL_KHR;
    }
    swapchainCreateInfo.imageExtent = surfaceCapabilities.currentExtent;
    // 旧交换链
    swapchainCreateInfo.oldSwapchain = swapchain;
    // 等待设备限制（渲染、呈现循环）
    auto qGraphics = device.getQueueGraphics();
    auto qPresentation = device.getQueuePresentation();
    auto result = vkQueueWaitIdle(qGraphics);
    if (!result && qGraphics != qPresentation)
        result = vkQueueWaitIdle(qPresentation);
    returnVkError("Failed to wait for queue to be idle!");
    // 销毁 ImageView
    destroyDeviceHandles(vkDestroyImageView, swapchainImageViews);
    invokeDestroyCallbacks;
    // 创建 Swapchain
    result = createSwapchainInternal();  
    if (result) return result;  
    invokeCreateCallbacks;  
    return VK_SUCCESS;
}
```
# 获取交换链图像索引

使用 `vkAcquireNextImageKHR` 获取下一张用于渲染交换链图像的索引

> [!attention] 连续几次获取的图像索引不一定连续

> [!danger] 注意处理重建交换链的情况

> [!example] 实例代码中没有考虑超时问题
> 超时时间被设置为 `UINT64_MAX`，即不限制，因此不需要考虑 `VK_TIMEOUT` 和 `VK_NOT_READY` 情况

```cpp
VkResult Swapchain::swapImage(VkSemaphore isImageAvailable) {  
    auto &device = vk::Device::base();  
    // 销毁旧交换链  
    if (swapchainCreateInfo.oldSwapchain && swapchainCreateInfo.oldSwapchain != handle) {  
        destroyDeviceHandle(vkDestroySwapchainKHR);  
    }  
  
    while (auto result = vkAcquireNextImageKHR(device, handle, UINT64_MAX, isImageAvailable, VK_NULL_HANDLE, &currentImageIndex)) {  
        switch (result) {  
            case VK_SUBOPTIMAL_KHR:  
            case VK_ERROR_OUT_OF_DATE_KHR:  
                // 重建交换链  
                recreate();  
                break;  
            default:  
                returnVkError("Failed to acquire the next image!");  
        }  
    }  
  
    return VK_SUCCESS;  
}
```
# 呈现图像

若呈现的队列族与图形队列族不一致，需要使用 `vkQueuePresentKHR` 手动呈现图像

| 成员                   | 类型                | 说明                                   |
| -------------------- | ----------------- | ------------------------------------ |
| `sType`              |                   | `VK_STRUCTURE_TYPE_PRESENT_INFO_KHR` |
| `waitSemaphoreCount` | `uint32_t`        | 所需等待被置位的信号量的个数                       |
| `pWaitSemaphores`    | `VkSemaphore*`    | 指向所需等待被置位的信号量的数组                     |
| `swapchainCount`     | `uint32_t`        | 有图像需要被呈现的交换链的个数                      |
| `pSwapchains`        | `VkSwapchainKHR*` | 指向有图像需要被呈现的交换链的数组                    |
| `pImageIndices`      | `uint32_t*`       | 指向各个交换链中需要被呈现的图像的索引构成的数组             |
| `pResults`           | `VkResult*`       | 各个交换链中各图像的呈现结果，可以是 `nullptr`         |

> [!tip] 多个交换链适用于多窗口等情况

> [!warning] 注意处理重建交换链的情况
> 这里直接重建交换链后返回，会丢一帧。可以在重建交换链后重新执行[[#获取交换链图像索引]]、[[#呈现图像]]两步

```cpp
VkResult Swapchain::presentImage(VkPresentInfoKHR *info) {
    auto result = vkQueuePresentKHR(Device::base().getQueuePresentation(), info);
    switch (result) {
        case VK_SUCCESS:
            break;
        case VK_SUBOPTIMAL_KHR:
        case VK_ERROR_OUT_OF_DATE_KHR:
            // 重建交换链
            return recreate();
        default:
            returnVkError("Failed to queue the image for presentation!");
    }

    return VK_SUCCESS;
}
```
# 封装

```cpp
namespace vk {

    constexpr char TYPENAME_SWAPCHAIN[] = "VkSwapchain";

    class Swapchain : public VkHandle<VkSwapchainKHR, TYPENAME_SWAPCHAIN> {
    SingletonClass(Swapchain);

    private:
        std::vector<VkSurfaceFormatKHR> availableSurfaceFormats;
        VkSwapchainCreateInfoKHR swapchainCreateInfo {};
        std::vector<VkImage> swapchainImages;
        std::vector<VkImageView> swapchainImageViews;
        std::vector<std::function<void()>> createCallbacks;
        std::vector<std::function<void()>> destroyCallbacks;

        // 渲染链
        uint32_t currentImageIndex = 0;

        VkResult createSwapchainInternal();
    public:

        ~Swapchain() override;

        VkResult initialize(VkExtent2D size, bool limitFrameRate = true, VkSwapchainCreateFlagsKHR flags = 0);

        VkResult recreate();

        VkResult getSurfaceFormats();

        VkResult setSurfaceFormat(VkSurfaceFormatKHR surfaceFormat);

        void addCreateCallback(const std::function<void()>& callback);

        void addDestroyCallback(const std::function<void()>& callback);

        VkResult swapImage(VkSemaphore isImageAvailable);

        VkResult presentImage(VkPresentInfoKHR *info);

        VkResult presentImage(uint32_t semaphoreCount, VkSemaphore* waitSemaphores);

        VkResult presentImage(VkSemaphore waitSemaphore) {
            return presentImage(1, &waitSemaphore);
        }
    };

} // vk
```