> [!note] 设备：图形设备，通常为 GPU，也可以是非实体设备，使用 VkPhysicalDevice 类指代，通过这类 Handler 可以获取设备信息

> [!note] 逻辑设备：编程层面上与物理设备交互的对象，使用 VkDevice 指代，通过这类 Handler 可以分配内存、创建 Vulkan 对象等
# 选择物理设备
## 获取设备列表

```cpp
VkResult graphicsBase::getPhysicalDevices() {
    uint32_t deviceCount; // 物理设备数量
    if (auto result = vkEnumeratePhysicalDevices(instance, &deviceCount, nullptr)) {
        std::cout << std::format("[ graphicsBase ] ERROR\n"
                                 "Failed to get the count of physical devices!\n"
                                 "Error code: {}\n", int32_t(result));
        return result;
    }
    if (!deviceCount) {
        std::cout << "[ graphicsBase ] ERROR\n"
                     "Failed to find any physical device supports vulkan!\n";
        // 无物理设备
        abort();
    }
    
    availablePhysicalDevices.resize(deviceCount); // 物理设备列表
    auto result = vkEnumeratePhysicalDevices(instance, &deviceCount, availablePhysicalDevices.data());
    if (result) {
        std::cout << std::format("[ graphicsBase ] ERROR\n"
                                 "Failed to enumerate physical devices!\n"
                                 "Error code: {}\n", int32_t(result));
    }
    return result;
}
```
## 检查队列族

> [!note] 队列：类似线程，命令执行引擎的接口，规定支持图形、计算、数据传送、稀疏绑定等操作
> 队列族：一组功能相同的队列。支持 Vulkan 的显卡驱动器至少有一个同时支持图形和计算的队列族

对于存在多个设备的计算机，需要遍历所有获取的设备，根据需要求（通常为图形、计算、展示）选择

```cpp fold
VkResult
graphicsBase::determinePhysicalDevice(uint32_t deviceIndex, bool enableGraphicsQueue, bool enableComputeQueue) {
    static constexpr uint32_t notFound = INT32_MAX;
    // 三元组 存储物理设备的队列索引
    struct queueFamilyIndexCombination {
        uint32_t graphics     = VK_QUEUE_FAMILY_IGNORED;
        uint32_t presentation = VK_QUEUE_FAMILY_IGNORED;
        uint32_t compute      = VK_QUEUE_FAMILY_IGNORED;
    };
    static std::vector<queueFamilyIndexCombination> combinations(availablePhysicalDevices.size());
    auto &[ig, ip, ic] = combinations[deviceIndex];
    
    // 该设备已检查过且不支持，直接跳过
    if (ig == notFound && enableGraphicsQueue ||
        ip == notFound && surface ||
        ic == notFound && enableComputeQueue) {
        return VK_RESULT_MAX_ENUM;
    }
    
    if (ig == VK_QUEUE_FAMILY_IGNORED && enableGraphicsQueue ||
        ip == VK_QUEUE_FAMILY_IGNORED && surface ||
        ic == VK_QUEUE_FAMILY_IGNORED && enableComputeQueue) {
        uint32_t indices[3];
        auto result = getQueueFamilyIndices(availablePhysicalDevices[deviceIndex], enableGraphicsQueue, enableComputeQueue, indices);
        
        if (result == VK_SUCCESS || result == VK_RESULT_MAX_ENUM) {
            if (enableGraphicsQueue) ig = indices[0] & INT32_MAX;
            if (surface)             ip = indices[1] & INT32_MAX;
            if (enableComputeQueue)  ic = indices[2] & INT32_MAX;
        }
        
        if (result) {
            return result;
        }
    } else {
        queueFamilyIndex_graphics = enableGraphicsQueue ? ig : VK_QUEUE_FAMILY_IGNORED;
        queueFamilyIndex_presentation = surface         ? ip : VK_QUEUE_FAMILY_IGNORED;
        queueFamilyIndex_compute = enableComputeQueue   ? ic : VK_QUEUE_FAMILY_IGNORED;
    }
    physicalDevice = availablePhysicalDevices[deviceIndex];
    return VK_SUCCESS;
}

VkResult graphicsBase::getQueueFamilyIndices(VkPhysicalDevice physicalDevice,
                                             bool enableGraphicsQueue, bool enableComputeQueue,
                                             uint32_t (&queueFamilyIndices)[3]) {
    // 获取设备的队列族
    uint32_t queueFamilyCount;
    vkGetPhysicalDeviceQueueFamilyProperties(physicalDevice, &queueFamilyCount, nullptr);
    if (!queueFamilyCount)
        return VK_RESULT_MAX_ENUM;
    
    std::vector<VkQueueFamilyProperties> queueFamilyPropertiesList(queueFamilyCount);
    vkGetPhysicalDeviceQueueFamilyProperties(physicalDevice, &queueFamilyCount, queueFamilyPropertiesList.data());
    
    auto &[ig, ip, ic] = queueFamilyIndices;
    ig = VK_QUEUE_FAMILY_IGNORED; // 图形
    ip = VK_QUEUE_FAMILY_IGNORED; // 呈现
    ic = VK_QUEUE_FAMILY_IGNORED; // 计算
    for (uint32_t i = 0; i < queueFamilyCount; ++i) {
        // 检查设备 i 每个队列族图形、呈现、计算的支持情况
        auto supportGraphics = enableGraphicsQueue && queueFamilyPropertiesList[i].queueFlags & VK_QUEUE_GRAPHICS_BIT;
        auto supportCompute = enableComputeQueue && queueFamilyPropertiesList[i].queueFlags & VK_QUEUE_COMPUTE_BIT;
        VkBool32 supportPresentation = false;
        if (surface) {
            if (auto result = vkGetPhysicalDeviceSurfaceSupportKHR(physicalDevice, i, surface,&supportPresentation)) {
                std::cout << std::format("[ graphicsBase ] ERROR\n"
                                         "Failed to determine if the queue family supports presentation!\n"
                                         "Error code: {}\n", int32_t(result));
                return result;
            }
        }
        
        if (supportGraphics && supportPresentation) {
            // 三者都满足，直接返回 i
            if (supportPresentation) {
                ig = ip = ic = i;
                break;
            }
            
            // 后面直到 for 结束，都是假定可能不存在一个同时支持图形、计算、呈现的队列族
            // 若确定一定存在该族的情况，可以删除
            if (ig != ic || ig == VK_QUEUE_FAMILY_IGNORED) {
                ig = ic = i;
            }
            
            // 不需要呈现时，也可以使用 i
            if (!surface) {
                break;
            }
        }
        if (supportGraphics     && ig == VK_QUEUE_FAMILY_IGNORED) ig = i;
        if (supportPresentation && ip == VK_QUEUE_FAMILY_IGNORED) ip = i;
        if (supportCompute      && ic == VK_QUEUE_FAMILY_IGNORED) ic = i;
    }
    
    if (ig == VK_QUEUE_FAMILY_IGNORED && enableGraphicsQueue ||
        ip == VK_QUEUE_FAMILY_IGNORED && surface ||
        ic == VK_QUEUE_FAMILY_IGNORED && enableComputeQueue) {
        return VK_RESULT_MAX_ENUM;
    }
    
    // 若已找到，记录队列族 id
    queueFamilyIndex_graphics     = ig;
    queueFamilyIndex_presentation = ip;
    queueFamilyIndex_compute      = ic;
    return VK_SUCCESS;
}
```

假设目标设备存在一个同时满足执行图形、计算、展示三种需求的队列的设备，则可以简化为：

```cpp
VkResult
graphicsBase::determinePhysicalDevice(uint32_t deviceIndex, bool enableGraphicsQueue, bool enableComputeQueue) {
    static constexpr uint32_t notFound = INT32_MAX;
    // 三元组 存储物理设备的队列索引
    static std::vector<QueueFamilyIndex> combinations(availablePhysicalDevices.size());
    auto &[ig, ip, ic] = combinations[deviceIndex];
    
    // 该设备已检查过且不支持，直接跳过
    if (ig == notFound && enableGraphicsQueue ||
        ip == notFound && surface ||
        ic == notFound && enableComputeQueue) {
        return VK_OTHER_ERROR;
    }
    
    auto apDevice = availablePhysicalDevices[deviceIndex];
    if (ig == VK_QUEUE_FAMILY_IGNORED && enableGraphicsQueue ||
        ip == VK_QUEUE_FAMILY_IGNORED && surface ||
        ic == VK_QUEUE_FAMILY_IGNORED && enableComputeQueue) {
        uint32_t indices[3];
        auto result = getQueueFamilyIndices(apDevice);
        if (result == VK_SUCCESS || result == VK_OTHER_ERROR) {
            if (enableGraphicsQueue) ig = indices[0] & INT32_MAX;
            if (surface)             ip = indices[1] & INT32_MAX;
            if (enableComputeQueue)  ic = indices[2] & INT32_MAX;
        }
        
        if (result) {
            return result;
        }
    } else {
        queueFamilyIndex.graphics     = enableGraphicsQueue ? ig : VK_QUEUE_FAMILY_IGNORED;
        queueFamilyIndex.presentation = surface             ? ip : VK_QUEUE_FAMILY_IGNORED;
        queueFamilyIndex.compute      = enableComputeQueue  ? ic : VK_QUEUE_FAMILY_IGNORED;
    }
    physicalDevice = apDevice;
    return VK_SUCCESS;
}

VkResult graphicsBase::getQueueFamilyIndices(VkPhysicalDevice physicalDevice) {
    // 获取设备的队列族
    uint32_t queueFamilyCount;
    vkGetPhysicalDeviceQueueFamilyProperties(physicalDevice, &queueFamilyCount, nullptr);
    if (!queueFamilyCount)
        return VK_OTHER_ERROR;
    
    std::vector<VkQueueFamilyProperties> queueFamilyPropertiesList(queueFamilyCount);
    vkGetPhysicalDeviceQueueFamilyProperties(physicalDevice, &queueFamilyCount, queueFamilyPropertiesList.data());
    
    for (uint32_t i = 0; i < queueFamilyCount; ++i) {
        // 这里假定必定有一个同时支持绘制、计算、显示的队列族
        auto supportGraphics = queueFamilyPropertiesList[i].queueFlags & VK_QUEUE_GRAPHICS_BIT;
        auto supportCompute  = queueFamilyPropertiesList[i].queueFlags & VK_QUEUE_COMPUTE_BIT;
        VkBool32 supportPresentation = false;
        if (surface) {
            if (auto result = vkGetPhysicalDeviceSurfaceSupportKHR(physicalDevice, i, surface, &supportPresentation)) {
                std::cout << std::format("[ graphicsBase ] ERROR\n"
                                         "Failed to determine if the queue family supports presentation!\n"
                                         "Error code: {}\n", int32_t(result));
                return result;
            }
        }
        
        if (supportGraphics && supportCompute && (!surface || supportPresentation)) {
            queueFamilyIndex.graphics = i;
            queueFamilyIndex.compute  = i;
            if (surface)
                queueFamilyIndex.presentation = i;
            return VK_SUCCESS;
        }
    }
    
    return VK_OTHER_ERROR;
}
```
# 初始化逻辑设备

选择好物理设备后，根据设备信息初始化逻辑设备。设备级扩展列表 `deviceExtensions` 详见[[Vulkan 实例#层与扩展]]
## 设备队列信息

根据前面选择设备的信息，初始化队列族信息

| 成员                 | 类型             | 说明                                           |
| ------------------ | -------------- | -------------------------------------------- |
| `sType`            |                | `VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO` |
| `queueFamilyIndex` | `uint32_t`     | 队列族索引                                        |
| `queueCount`       | `uint32_t`     | 在该队列族索引下，所须创建的队列个数                           |
| `pQueuePriorities` | `const float*` | 指向浮点数的数组，用于指定各个队列的优先级，浮点数范围在 0 到 1 之间，1 最大   |

> [!note] `flags` 支持一个 `VK_DEVICE_QUEUE_CREATE_PROTECTED_BIT`，表示创建受保护的队列，使 Vulkan 设备内存无法被主机读取，只能被写入，用于 DRM 内容

```cpp
// 优先级，这里都设置成 1
float queuePriority = 1.0f;
VkDeviceQueueCreateInfo queueCreateInfos[3] = {
        {
                .sType = VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO,
                .queueCount = 1,
                .pQueuePriorities = &queuePriority
        },
        {
                .sType = VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO,
                .queueCount = 1,
                .pQueuePriorities = &queuePriority
        },
        {
                .sType = VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO,
                .queueCount = 1,
                .pQueuePriorities = &queuePriority
        }
};
// 设置队列族信息
uint32_t queueCreateInfoCount = 0;
if (queueFamilyIndex_graphics != VK_QUEUE_FAMILY_IGNORED)
    queueCreateInfos[queueCreateInfoCount++].queueFamilyIndex = queueFamilyIndex_graphics;
if (queueFamilyIndex_presentation != VK_QUEUE_FAMILY_IGNORED &&
    queueFamilyIndex_graphics != queueFamilyIndex_presentation)
    queueCreateInfos[queueCreateInfoCount++].queueFamilyIndex = queueFamilyIndex_presentation;
if (queueFamilyIndex_compute != VK_QUEUE_FAMILY_IGNORED &&
    queueFamilyIndex_graphics != queueFamilyIndex_compute &&
    queueFamilyIndex_presentation != queueFamilyIndex_compute)
    queueCreateInfos[queueCreateInfoCount++].queueFamilyIndex = queueFamilyIndex_compute;
```
## 逻辑设备对象

| 成员                        | 类型                               | 说明                                           |
| ------------------------- | -------------------------------- | -------------------------------------------- |
| `sType`                   |                                  | `VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO`       |
| `queueCreateInfoCount`    | `uint32_t`                       | 队列的创建信息的个数                                   |
| `pQueueCreateInfos`       | `const VkDeviceQueueCreateInfo*` | 指向由队列的创建信息构成的数组                              |
| `enabledLayerCount`       | `uint32_t`                       | （已弃用）所需额外开启的设备级别层数                           |
| `ppEnabledLayerNames`     | `const char* const*`             | （已弃用）指向由所需开启的层的名称构成的数组                       |
| `enabledExtensionCount`   | `uint32_t`                       | 所需额外开启的设备级别扩展数                               |
| `ppEnabledExtensionNames` | `const char* const*`             | 指向由所需开启的扩展的名称构成的数组（同一名称可以重复出现）               |
| `pEnabledFeatures`        | `VkPhysicalDeviceFeatures*`      | 指向一个 VkPhysicalDeviceFeatures 结构体，指明需要开启哪些特性 |

> [!hint] 设备物理特性可以全部开启，不会影响程序初始化或渲染效率

```cpp
// 获取物理设备特性，生成设备信息
const char *deviceExtensions[] = {  
        VK_KHR_SWAPCHAIN_EXTENSION_NAME,  
};
uint32_t deviceExtensionsCount = 1;
VkPhysicalDeviceFeatures physicalDeviceFeatures;
vkGetPhysicalDeviceFeatures(physicalDevice, &physicalDeviceFeatures);
VkDeviceCreateInfo deviceCreateInfo = {
        .sType = VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
        .flags = flags,
        .queueCreateInfoCount = queueCreateInfoCount,
        .pQueueCreateInfos = queueCreateInfos,
        .enabledExtensionCount = deviceExtensionsCount,
        .ppEnabledExtensionNames = deviceExtensions,
        .pEnabledFeatures = &physicalDeviceFeatures,
};

// 创建逻辑设备
if (auto result = vkCreateDevice(physicalDevice, &deviceCreateInfo, nullptr, &device)) {
    std::cout << std::format("[ graphicsBase ] ERROR\n"
                             "Failed to create a vulkan logical device!\n"
                             "Error code: {}\n", int32_t(result));
    return result;
}

// 获取各队列族队列
if (queueFamilyIndex_graphics != VK_QUEUE_FAMILY_IGNORED)
    vkGetDeviceQueue(device, queueFamilyIndex_graphics, 0, &queue_graphics);
if (queueFamilyIndex_presentation != VK_QUEUE_FAMILY_IGNORED)
    vkGetDeviceQueue(device, queueFamilyIndex_presentation, 0, &queue_presentation);
if (queueFamilyIndex_compute != VK_QUEUE_FAMILY_IGNORED)
    vkGetDeviceQueue(device, queueFamilyIndex_compute, 0, &queue_compute);

// 更新物理设备信息
vkGetPhysicalDeviceProperties(physicalDevice, &physicalProperties);
vkGetPhysicalDeviceMemoryProperties(physicalDevice, &physicalMemoryProperties);
```
## 重建设备

当更换物理设备等情况出现，需要重建设备，需要处理的有：
- 使用 `vkDeviceWaitIdle(device)` 等待设备空闲
- 使用 `vkDestroySpawnchainKHR` 销毁交换链
- 使用 `vkDestroyDevice` 销毁设备

```cpp
// 等待设备空闲
if (auto result = vkDeviceWaitIdle(device)) {
    std::cout << std::format("[ graphicsBase ] ERROR\n"
                             "Failed to wait for the device to be idle!\n"
                             "Error code: {}\n", int32_t(result));
    return result;
}
// 销毁交换链
if (swapchain) {
    for (const auto &callback: destroySwapchainCallback)
        callback();
    for (const auto &view: swapchainImageViews)
        vkDestroyImageView(device, view, nullptr);
    swapchainImageViews.resize(0);
    vkDestroySwapchainKHR(device, swapchain, nullptr);
    swapchain = VK_NULL_HANDLE;
    swapchainCreateInfo = {};
}
// 销毁逻辑设备
if (device) {
    for (const auto &callback: destroyDeviceCallback)
        callback();
    vkDestroyDevice(device, nullptr);
    device = VK_NULL_HANDLE;
}

return createDevice(flags);
```
# 封装

```cpp
namespace vk {

    constexpr char TYPENAME_DEVICE[] = "VkDevice";

    struct QueueFamilyIndex {
        uint32_t graphics = VK_QUEUE_FAMILY_IGNORED;
        uint32_t presentation = VK_QUEUE_FAMILY_IGNORED;
        uint32_t compute = VK_QUEUE_FAMILY_IGNORED;
    };

    class Device : public VkHandle<VkDevice, TYPENAME_DEVICE> {
    SingletonClass(Device);

    private:
        VkPhysicalDevice physicalDevice;
        VkPhysicalDeviceProperties physicalProperties;
        VkPhysicalDeviceMemoryProperties physicalMemoryProperties;
        std::vector<VkPhysicalDevice> availablePhysicalDevices;
        QueueFamilyIndex queueFamilyIndex {};
        VkQueue queueGraphics;
        VkQueue queuePresentation;
        VkQueue queueCompute;
        std::vector<std::function<void()>> createCallbacks;
        std::vector<std::function<void()>> destroyCallbacks;

    public:

        virtual ~Device();

        VkResult initialize(uint32_t deviceIndex = 0,
                            bool enableGraphicsQueue = true,
                            bool enableComputeQueue = true,
                            VkDeviceCreateFlags flags = 0);

        VkResult create(VkDeviceCreateFlags flags = 0);

        VkResult getPhysicalDevices();

        VkResult getQueueFamilyIndices(VkPhysicalDevice vkPhysicalDevice);

        VkResult determinePhysicalDevice(uint32_t deviceIndex = 0,
                                         bool enableGraphicsQueue = true,
                                         bool enableComputeQueue = true);

        VkResult recreate(VkDeviceCreateFlags flags = 0);

        void addCreateCallback(const std::function<void()>& callback);

        void addDestroyCallback(const std::function<void()>& callback);

        VkPhysicalDevice getPhysicalDevice() const;

        const VkPhysicalDeviceProperties& getPhysicalProperties() const;

        const VkPhysicalDeviceMemoryProperties& getPhysicalMemoryProperties() const;

        const QueueFamilyIndex& getQueueFamilyIndex() const;

        VkQueue getQueueGraphics() const;

        VkQueue getQueuePresentation() const;

        VkQueue getQueueCompute() const;
    };
} // vk

```