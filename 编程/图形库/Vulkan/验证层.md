> [!warning] Valkan 没有内置验证层，只有安装了 Vulkan SDK 的设备才可用验证层
> `#NDEBUG` 宏可用于检查非调试环境

> [!tip] 验证层
> Vulkan SDK 引入验证层系统用于检验 Vulkan 参数、对象、线程、调用等信息，并将参数记录输出。参考 [[document/【Vulkan 学习笔记】4.1.3 Validation layers - 哔哩哔哩]]

获取验证层捕捉的 debug 信息，用于调试，使用 `VkDebugUtilsMessengerCreateInfoEXT` 创建

| 成员                | 类型                                     | 说明                                                              |
| ----------------- | -------------------------------------- | --------------------------------------------------------------- |
| `messageSeverity` | `VkDebugUtilsMessageSeverityFlagsEXT`  | 获取 debug 信息的严重性，由 `VkDebugUtilsMessageSeverityFlagBitsEXT` 组合而成 |
| `messageType`     | `VkDebugUtilsMessageTypeFlagsEXT`      | 获取 debug 信息类型，由 `VkDebugUtilsMessageTypeFlagBitsEXT` 组合而成       |
| `pfnUserCallback` | `PFN_vkDebugUtilsMessengerCallbackEXT` | debug 信息的自定义回调函数，返回值必须是 VK_FALSE                                |
| `pUserData`       | `void*`                                | 提供一个地址，之后如有需要，可以让自定义回调函数将数据存入该地址                                |

```cpp
#ifndef NDEBUG
        // 开发环境下，创建 Debug Messenger
        VkDebugUtilsMessengerCreateInfoEXT messengerCreateInfo = {
                .sType = VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT,
                .messageSeverity = VK_DEBUG_UTILS_MESSAGE_SEVERITY_WARNING_BIT_EXT |
                                   VK_DEBUG_UTILS_MESSAGE_SEVERITY_ERROR_BIT_EXT,
                .messageType = VK_DEBUG_UTILS_MESSAGE_TYPE_GENERAL_BIT_EXT |
                               VK_DEBUG_UTILS_MESSAGE_TYPE_VALIDATION_BIT_EXT |
                               VK_DEBUG_UTILS_MESSAGE_TYPE_PERFORMANCE_BIT_EXT,
                .pfnUserCallback = [](VkDebugUtilsMessageSeverityFlagBitsEXT messageSeverity,
                                      VkDebugUtilsMessageTypeFlagsEXT messageType,
                                      const VkDebugUtilsMessengerCallbackDataEXT *pCallbackData,
                                      void *pUserData) -> VkBool32 {
                    // 错误信息处理回调
                    std::cout << pCallbackData->pMessage << "\n";
                    return VK_FALSE;
                },
        };
        if (auto createFunc = getProcAddr(vkCreateDebugUtilsMessengerEXT)) {
            auto result = createFunc(VulkanInstance::base(), &messengerCreateInfo, nullptr, &handle);
            returnVkError("Failed to allocate a debug messenger!"); // if (result) { cout<<msg; return result; }
        } else {
            // cout<<msg; return VK_OTHER_ERROR;
            returnVkMessage("Failed to get the function pointer of vkCreateDebugUtilsMessengerEXT!");
        }
#endif
```
# 封装

主要封装一个初始化函数

```cpp
namespace vk {

    constexpr char TYPENAME_DEBUG_MESSENGER[] = "VkDebugMessenger";

    class DebugMessenger : public VkHandle<VkDebugUtilsMessengerEXT, TYPENAME_DEBUG_MESSENGER> {
    SingletonClass(DebugMessenger);

    public:

        ~DebugMessenger() override;

        VkResult initialize(VkDebugUtilsMessengerCreateFlagsEXT flags = 0);

        static void handleDebugMessenger(
                VkDebugUtilsMessageSeverityFlagBitsEXT           messageSeverity,
                VkDebugUtilsMessageTypeFlagsEXT                  messageTypes,
                const VkDebugUtilsMessengerCallbackDataEXT*      pCallbackData,
                void*                                            pUserData);
    };
} // vk
```